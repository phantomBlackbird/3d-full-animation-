<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Landscape Mobile 3D Game</title>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.0.0/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.2/dist/aframe-environment-component.min.js"></script>

    <style>
      /* Force Landscape Message */
      @media screen and (orientation: portrait) {
        #landscape-msg { display: flex; }
      }
      #landscape-msg {
        display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: #000; color: white; z-index: 10000; justify-content: center; align-items: center; text-align: center;
      }

      /* Half-Sized D-Pads */
      .ui-container {
        position: fixed; bottom: 10px; z-index: 999; user-select: none;
      }
      #controls { left: 10px; display: grid; grid-template-areas: ". u ." "l . r" ". d ."; gap: 5px; }
      #actions { right: 10px; display: grid; grid-template-areas: ". j ." "s . t" ". c ."; gap: 8px; }

      .btn, .action-btn {
        width: 35px; height: 35px; /* Half size */
        background: rgba(255, 255, 255, 0.2); border: 1px solid #fff; border-radius: 5px;
        display: flex; align-items: center; justify-content: center; color: white; font-size: 8px; touch-action: none;
      }
      .action-btn { border-radius: 50%; background: rgba(255, 165, 0, 0.3); width: 40px; height: 40px; }
      
      #up { grid-area: u; } #down { grid-area: d; } #left { grid-area: l; } #right { grid-area: r; }
      #jump { grid-area: j; } #sneak { grid-area: s; } #turn { grid-area: t; } #crouch { grid-area: c; }
    </style>
  </head>

  <body>
    <div id="landscape-msg"><h1>Please Rotate to Landscape Mode</h1></div>

    <div id="controls" class="ui-container">
      <div id="up" class="btn">▲</div>
      <div id="left" class="btn">◀</div>
      <div id="right" class="btn">▶</div>
      <div id="down" class="btn">▼</div>
    </div>

    <div id="actions" class="ui-container">
      <div id="jump" class="action-btn">JUMP</div>
      <div id="sneak" class="action-btn">SNEAK</div>
      <div id="turn" class="action-btn">180</div>
      <div id="crouch" class="action-btn">CROUCH</div>
    </div>

<a-scene vr-mode-ui="enabled: false">
  <a-assets>
    <a-asset-item id="playerModel" src="character-model.glb"></a-asset-item>
  </a-assets>

  <a-entity environment="preset: forest; dressingAmount: 300;"></a-entity>

  <a-entity id="player" position="0 0 0">
    
    <a-entity id="camera-orbit-rig" look-controls="pointerLockEnabled: false">
        <a-camera id="main-camera" wasd-controls-enabled="false" position="0 1.2 3" look-controls-enabled="false">
        </a-camera>
    </a-entity>

    <a-entity id="character"
              gltf-model="#playerModel"
              scale="0.011 0.011 0.011" 
              rotation="0 180 0"
              animation-mixer="clip: Idle_Static; crossFadeDuration: 0.4">
    </a-entity>
  </a-entity>
</a-scene>

<script>
const player = document.querySelector('#player');
const character = document.querySelector('#character');
const orbitRig = document.querySelector('#camera-orbit-rig');

// Movement configuration
let speed = 0.12; // Adjusted for a better feel on mobile
let moveDir = { x: 0, z: 0 };
let activeMove = false;
let isSneaking = false;

/**
 * 1. MOVEMENT DPAD LOGIC
 * We calculate direction relative to the camera angle in the tick function.
 */
const movementBtns = {
  up:    { x: 0,  z: -1 },
  down:  { x: 0,  z: 1 },
  left:  { x: -1, z: 0 },
  right: { x: 1,  z: 0 }
};

Object.keys(movementBtns).forEach(id => {
  const el = document.getElementById(id);
  
  el.addEventListener('touchstart', (e) => {
    e.preventDefault();
    moveDir = { x: movementBtns[id].x, z: movementBtns[id].z };
    activeMove = true;
    isSneaking = false;
    // Using Step_Stop for the standard move as requested
    character.setAttribute('animation-mixer', {
      clip: 'Step_Stop',
      crossFadeDuration: 0.2,
      loop: 'repeat'
    });
  });

  el.addEventListener('touchend', (e) => {
    e.preventDefault();
    activeMove = false;
    character.setAttribute('animation-mixer', {
      clip: 'Idle_Static',
      crossFadeDuration: 0.4
    });
  });
});

/**
 * 2. ACTION PAD LOGIC
 */
const actionMap = {
  jump:   { clip: 'Jump_Up', loop: 'once' },
  turn:   { clip: 'Turn_180', loop: 'once' },
  crouch: { clip: 'Crouch_Idle', loop: 'repeat' },
  sneak:  { clip: 'Sneak_Walk_A', loop: 'repeat' }
};

Object.keys(actionMap).forEach(id => {
  const el = document.getElementById(id);
  
  el.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const action = actionMap[id];
    
    if (id === 'sneak') {
      activeMove = true;
      isSneaking = true;
      moveDir = { x: 0, z: -1 }; // Sneak always moves "forward"
    }

    character.setAttribute('animation-mixer', {
      clip: action.clip,
      loop: action.loop,
      crossFadeDuration: 0.3
    });
  });

  el.addEventListener('touchend', (e) => {
    e.preventDefault();
    activeMove = false;
    isSneaking = false;
    character.setAttribute('animation-mixer', {
      clip: 'Idle_Static',
      crossFadeDuration: 0.4
    });
  });
});

/**
 * 3. CORE ENGINE: CAMERA-RELATIVE MOVEMENT
 * This runs every frame to calculate where "forward" is based on where you look.
 */
function tick() {
  if (activeMove) {
    const currentPos = player.getAttribute('position');
    const currentSpeed = isSneaking ? speed * 0.4 : speed;
    
    // Get the camera's current Y-axis rotation in Radians
    const cameraYaw = orbitRig.getAttribute('rotation').y * (Math.PI / 180);
    
    /**
     * DIRECTION MATH: 
     * We invert the signs to ensure "UP" pushes the player AWAY from the screen.
     */
    const rotatedX = - (moveDir.x * Math.cos(cameraYaw) + moveDir.z * Math.sin(cameraYaw));
    const rotatedZ = - (moveDir.z * Math.cos(cameraYaw) - moveDir.x * Math.sin(cameraYaw));

    // Apply movement to the player rig
    currentPos.x += rotatedX * currentSpeed;
    currentPos.z += rotatedZ * currentSpeed;
    player.setAttribute('position', currentPos);

    // ROTATE CHARACTER:
    // Calculate the angle of movement so the character faces where they are going.
    // + Math.PI (180 deg) offsets the default Mixamo model orientation.
    const moveAngle = Math.atan2(rotatedX, rotatedZ);
    character.setAttribute('rotation', {
      x: 0, 
      y: (moveAngle * (180 / Math.PI)) + 180, 
      z: 0
    });
  }
  requestAnimationFrame(tick);
}

// Start the game loop
tick();

</script>
  </body>
</html>
